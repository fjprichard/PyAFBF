

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API: auxiliary classes &mdash; PyAFBF  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Glossary" href="glossary.html" />
    <link rel="prev" title="API: main classes" href="field.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyAFBF
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstartguide.html">Quick start guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">Example gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="database.html">Generation of a database</a></li>
<li class="toctree-l1"><a class="reference internal" href="field.html">API: main classes</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API: auxiliary classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#periodic-functions-perfunction">Periodic functions (<em>perfunction</em>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction"><code class="docutils literal notranslate"><span class="pre">perfunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.ApplyTransforms"><code class="docutils literal notranslate"><span class="pre">perfunction.ApplyTransforms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.ChangeParameters"><code class="docutils literal notranslate"><span class="pre">perfunction.ChangeParameters()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.CheckValidity"><code class="docutils literal notranslate"><span class="pre">perfunction.CheckValidity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.ComputeFeatures"><code class="docutils literal notranslate"><span class="pre">perfunction.ComputeFeatures()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.ComputeFourierBasis"><code class="docutils literal notranslate"><span class="pre">perfunction.ComputeFourierBasis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.ComputeStepBasis"><code class="docutils literal notranslate"><span class="pre">perfunction.ComputeStepBasis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.Display"><code class="docutils literal notranslate"><span class="pre">perfunction.Display()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.Evaluate"><code class="docutils literal notranslate"><span class="pre">perfunction.Evaluate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.InitFourierFunction"><code class="docutils literal notranslate"><span class="pre">perfunction.InitFourierFunction()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.InitStepFunction"><code class="docutils literal notranslate"><span class="pre">perfunction.InitStepFunction()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.SampleFourierCoefficients"><code class="docutils literal notranslate"><span class="pre">perfunction.SampleFourierCoefficients()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.SampleStepConstants"><code class="docutils literal notranslate"><span class="pre">perfunction.SampleStepConstants()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.SampleStepIntervals"><code class="docutils literal notranslate"><span class="pre">perfunction.SampleStepIntervals()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.Save"><code class="docutils literal notranslate"><span class="pre">perfunction.Save()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.SetStepSampleMode"><code class="docutils literal notranslate"><span class="pre">perfunction.SetStepSampleMode()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.SetUniformStepInterval"><code class="docutils literal notranslate"><span class="pre">perfunction.SetUniformStepInterval()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.PeriodicFunction.perfunction.ShowParameters"><code class="docutils literal notranslate"><span class="pre">perfunction.ShowParameters()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#coordinates-coordinates">Coordinates (<em>coordinates</em>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#afbf.Classes.SpatialData.coordinates"><code class="docutils literal notranslate"><span class="pre">coordinates</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.coordinates.ApplyAffineTransform"><code class="docutils literal notranslate"><span class="pre">coordinates.ApplyAffineTransform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.coordinates.CheckValidity"><code class="docutils literal notranslate"><span class="pre">coordinates.CheckValidity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.coordinates.DefineNonUniformLocations"><code class="docutils literal notranslate"><span class="pre">coordinates.DefineNonUniformLocations()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.coordinates.DefineSparseSemiBall"><code class="docutils literal notranslate"><span class="pre">coordinates.DefineSparseSemiBall()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.coordinates.DefineUniformGrid"><code class="docutils literal notranslate"><span class="pre">coordinates.DefineUniformGrid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.coordinates.Display"><code class="docutils literal notranslate"><span class="pre">coordinates.Display()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.coordinates.ProjectOnAxis"><code class="docutils literal notranslate"><span class="pre">coordinates.ProjectOnAxis()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#spatial-data-sdata">Spatial data (<em>sdata</em>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#afbf.Classes.SpatialData.sdata"><code class="docutils literal notranslate"><span class="pre">sdata</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.sdata.ComputeEmpiricalSemiVariogram"><code class="docutils literal notranslate"><span class="pre">sdata.ComputeEmpiricalSemiVariogram()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.sdata.ComputeImageSign"><code class="docutils literal notranslate"><span class="pre">sdata.ComputeImageSign()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.sdata.ComputeIncrements"><code class="docutils literal notranslate"><span class="pre">sdata.ComputeIncrements()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.sdata.ComputeLaplacian"><code class="docutils literal notranslate"><span class="pre">sdata.ComputeLaplacian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.sdata.ComputeQuadraticVariations"><code class="docutils literal notranslate"><span class="pre">sdata.ComputeQuadraticVariations()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.sdata.CreateImage"><code class="docutils literal notranslate"><span class="pre">sdata.CreateImage()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.sdata.Display"><code class="docutils literal notranslate"><span class="pre">sdata.Display()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.sdata.ImportImage"><code class="docutils literal notranslate"><span class="pre">sdata.ImportImage()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.SpatialData.sdata.Save"><code class="docutils literal notranslate"><span class="pre">sdata.Save()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#process-process">Process (<em>process</em>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#afbf.Classes.RandomProcess.process"><code class="docutils literal notranslate"><span class="pre">process</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.RandomProcess.process.ComputeAutocovariance"><code class="docutils literal notranslate"><span class="pre">process.ComputeAutocovariance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.RandomProcess.process.ComputeAutocovarianceSpectrum"><code class="docutils literal notranslate"><span class="pre">process.ComputeAutocovarianceSpectrum()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.RandomProcess.process.ComputeFBMAutocovariance"><code class="docutils literal notranslate"><span class="pre">process.ComputeFBMAutocovariance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.RandomProcess.process.ComputeFBMSemiVariogram"><code class="docutils literal notranslate"><span class="pre">process.ComputeFBMSemiVariogram()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.RandomProcess.process.ComputeSemiVariogram"><code class="docutils literal notranslate"><span class="pre">process.ComputeSemiVariogram()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.RandomProcess.process.Display"><code class="docutils literal notranslate"><span class="pre">process.Display()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.RandomProcess.process.ExtendFBM"><code class="docutils literal notranslate"><span class="pre">process.ExtendFBM()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.RandomProcess.process.IntegrateProcess"><code class="docutils literal notranslate"><span class="pre">process.IntegrateProcess()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.RandomProcess.process.Simulate"><code class="docutils literal notranslate"><span class="pre">process.Simulate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Classes.RandomProcess.process.Simulate_CirculantCovarianceMethod"><code class="docutils literal notranslate"><span class="pre">process.Simulate_CirculantCovarianceMethod()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#variable-projection-minimize">Variable projection (<em>minimize</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#turning-bands-tbparameters">Turning bands (<em>tbparameters</em>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#afbf.Simulation.TurningBands.tbparameters"><code class="docutils literal notranslate"><span class="pre">tbparameters</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Simulation.TurningBands.tbparameters.DisplayInformation"><code class="docutils literal notranslate"><span class="pre">tbparameters.DisplayInformation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Simulation.TurningBands.tbparameters.OptimalAngles"><code class="docutils literal notranslate"><span class="pre">tbparameters.OptimalAngles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Simulation.TurningBands.tbparameters.Precision"><code class="docutils literal notranslate"><span class="pre">tbparameters.Precision()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Simulation.TurningBands.tbparameters.QuasiUniformAngles"><code class="docutils literal notranslate"><span class="pre">tbparameters.QuasiUniformAngles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#afbf.Simulation.TurningBands.tbparameters.SimulationCost"><code class="docutils literal notranslate"><span class="pre">tbparameters.SimulationCost()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ndarray">ndarray</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#afbf.utilities.ndarray"><code class="docutils literal notranslate"><span class="pre">ndarray</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="refs.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyAFBF</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API: auxiliary classes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/classes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-auxiliary-classes">
<h1>API: auxiliary classes<a class="headerlink" href="#api-auxiliary-classes" title="Link to this heading"></a></h1>
<p><em>Code author: Frédéric Richard &lt;frederic.richard_at_univ-amu.fr&gt;</em></p>
<section id="periodic-functions-perfunction">
<h2>Periodic functions (<em>perfunction</em>)<a class="headerlink" href="#periodic-functions-perfunction" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">afbf.Classes.PeriodicFunction.</span></span><span class="sig-name descname"><span class="pre">perfunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ftype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'step-smooth'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'noname'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class handles <span class="math notranslate nohighlight">\(\pi\)</span>-periodic positive parametric functions.</p>
<p id="perfunction">The available function representations are</p>
<ul class="simple">
<li><p>the representation in a Fourier basis,</p></li>
<li><p>a representation by step functions,</p></li>
<li><p>a representation by smoothed step functions.</p></li>
</ul>
<p>In the Fourier representation, the function is defined as</p>
<div class="math notranslate nohighlight">
\[f(t) = a_0 + \sum_{m=1}^M a_{m, 1} \cos(2mt)+a_{m, 2} \sin(2mt),\]</div>
<p>where <span class="math notranslate nohighlight">\(a_0\)</span> and <span class="math notranslate nohighlight">\(a_{m, k}\)</span> are real parameters.</p>
<p>A step function is defined as</p>
<div class="math notranslate nohighlight">
\[f(t) =
a_0 \left(
    \delta_{[-\frac{\pi}{2}, \psi_1)}(t)
    + \delta_{[\psi_{M+1}, \frac{\pi}{2})}(t)
    \right)
+ \sum_{m=1}^M a_i \delta_{[\psi_i, \psi_{i+1})}(t),\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> are non-negative parameters, and <span class="math notranslate nohighlight">\(\psi_i\)</span> are
ordered angles in <span class="math notranslate nohighlight">\([-\frac{\pi}{2}, \frac{\pi}{2})\)</span>.</p>
<p>The definition of step functions can be adapted to include smooth
transitions between intervals where the function is constant.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Representations are defined by an expansion of the form</p>
<div class="math notranslate nohighlight">
\[f(t) = \sum_{m=0}^M \alpha_m B_m(t)\]</div>
<p>for some coefficients <span class="math notranslate nohighlight">\(\alpha_m\)</span> and basis functions
<span class="math notranslate nohighlight">\(B_m\)</span>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><p>Definition of a function using the Fourier representation
with <span class="math notranslate nohighlight">\(M=3\)</span> (i.e. 7 coefficients).</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">afbf</span><span class="w"> </span><span class="kn">import</span> <span class="n">perfunction</span>
<span class="n">f1</span> <span class="o">=</span> <span class="n">perfunction</span><span class="p">(</span><span class="s1">&#39;Fourier&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Fourier&#39;</span><span class="p">)</span>
<span class="n">f1</span><span class="o">.</span><span class="n">Display</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/function-fourier.png" src="_images/function-fourier.png" />
<dl class="field-list simple">
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><p>Definition of a function with three steps.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">afbf</span><span class="w"> </span><span class="kn">import</span> <span class="n">perfunction</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">perfunction</span><span class="p">(</span><span class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;step function&#39;</span><span class="p">)</span>
<span class="n">f2</span><span class="o">.</span><span class="n">Display</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/function-step.png" src="_images/function-step.png" />
<dl class="field-list simple">
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><p>Definition of a smooth function with two steps.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">afbf</span><span class="w"> </span><span class="kn">import</span> <span class="n">perfunction</span>
<span class="n">f3</span> <span class="o">=</span> <span class="n">perfunction</span><span class="p">(</span><span class="s1">&#39;step-smooth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;smooth step function&#39;</span><span class="p">)</span>
<span class="n">f3</span><span class="o">.</span><span class="n">Display</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/function-smooth-step.png" src="_images/function-smooth-step.png" />
<dl class="field-list simple">
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><p>Definition of a step function with a ridge.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">afbf</span><span class="w"> </span><span class="kn">import</span> <span class="n">perfunction</span>
<span class="n">f4</span> <span class="o">=</span> <span class="n">perfunction</span><span class="p">(</span><span class="s1">&#39;ridge-step&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ridge function&#39;</span><span class="p">)</span>
<span class="n">f4</span><span class="o">.</span><span class="n">Display</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/function-ridge.png" src="_images/function-ridge.png" />
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – Name of the function.</p></li>
<li><p><strong>ftype</strong> (<em>str</em>) – <p>Type of the function representation.
Some predefined type are available:</p>
<blockquote>
<div><ul>
<li><p>’step’: step function.</p></li>
<li><p>’step-constant’: constant function.</p></li>
<li><p>’step-ridge’: a step function with ridges.</p></li>
<li><p>’step-smooth’: smooth step function.</p></li>
<li><p>’Fourier’: Fourier representation.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>fparam</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – Representation parameters <span class="math notranslate nohighlight">\(\alpha_m\)</span>.</p></li>
<li><p><strong>finter</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – Interval bounds <span class="math notranslate nohighlight">\(\psi_i\)</span> for a step function.</p></li>
<li><p><strong>steptrans</strong> (<em>boolean</em>) – True if there are transitions between step.</p></li>
<li><p><strong>trans</strong> (<em>int</em>) – indicate where step transitions are on even or odd intervals ({0, 1}).</p></li>
<li><p><strong>basis</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – an array where values of the mth basis function <span class="math notranslate nohighlight">\(B_m\)</span>
of the representation are on the mth row.</p></li>
<li><p><strong>t</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – positions at which to evaluate the function.</p></li>
<li><p><strong>stats</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – Basics statistics;
min, max, mean, median of the function.</p></li>
<li><p><strong>dev</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – Measures of deviations of the function; standard deviation,
absolute deviations to the mean and to the median.</p></li>
<li><p><strong>sharpness</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – Measures of sharpness computed on discrete function
derivative (discrete tv-norm, maximum of absolute discrete derivative).</p></li>
<li><p><strong>smode</strong> – Simulation mode of a step function (see <a class="reference internal" href="#setstepsamplemode">SetStepSampleMode</a>).</p></li>
<li><p><strong>translate</strong> (<em>float</em>) – Translation to be applied to the function (defaut to 0).</p></li>
<li><p><strong>rescale</strong> (<em>float</em>) – Factor of a rescaling to be applied to the function.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.ApplyTransforms">
<span class="sig-name descname"><span class="pre">ApplyTransforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">translate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.ApplyTransforms" title="Link to this definition"></a></dt>
<dd><p>Apply translation and/or rescaling transform to the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>translate</strong> (<em>float</em>) – Translation.</p></li>
<li><p><strong>rescale</strong> (<em>float</em>) – scaling factor (must be positive).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attributes translate, rescale.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.ChangeParameters">
<span class="sig-name descname"><span class="pre">ChangeParameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fparam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">finter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.ChangeParameters" title="Link to this definition"></a></dt>
<dd><p>Change parameters of the function while keeping its
representation.</p>
<p>If parameters are not given, the parameters are changed at random.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fparam</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>, optional.) – Parameters of the function. The default is None.</p></li>
<li><p><strong>finter</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>, optional) – Step interval bounds (only for step functions).
The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attributes fparam.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.CheckValidity">
<span class="sig-name descname"><span class="pre">CheckValidity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.CheckValidity" title="Link to this definition"></a></dt>
<dd><p>Check the validity of the periodic function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if attributes are properly defined.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.ComputeFeatures">
<span class="sig-name descname"><span class="pre">ComputeFeatures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.ComputeFeatures" title="Link to this definition"></a></dt>
<dd><p>Compute some features describing the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>m</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of discrete positions to evaluate the function.
Default to 10000.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Precision of the evaluation.</p>
</dd>
<dt class="field-odd">Rtypes<span class="colon">:</span></dt>
<dd class="field-odd"><p>scalar</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attributes stats, dev, sharpness.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.ComputeFourierBasis">
<span class="sig-name descname"><span class="pre">ComputeFourierBasis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.ComputeFourierBasis" title="Link to this definition"></a></dt>
<dd><p>Compute basis functions of the Fourier representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Attribute basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.ComputeStepBasis">
<span class="sig-name descname"><span class="pre">ComputeStepBasis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.ComputeStepBasis" title="Link to this definition"></a></dt>
<dd><p>Compute basis functions of a representation by a step function at
positions given in attribute t.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Attribute basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.Display">
<span class="sig-name descname"><span class="pre">Display</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nfig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.Display" title="Link to this definition"></a></dt>
<dd><p>Plot the graph of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nfig</strong> (<em>int</em><em>, </em><em>optional</em>) – The index of the figure. Default to 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.Evaluate">
<span class="sig-name descname"><span class="pre">Evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.Evaluate" title="Link to this definition"></a></dt>
<dd><p>Evaluate the function at some positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>, optional.) – Positions at which the function is computed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute values.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If parameter t is omitted, the function is evaluated
at points of the previous call of the function.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.InitFourierFunction">
<span class="sig-name descname"><span class="pre">InitFourierFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'init'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.InitFourierFunction" title="Link to this definition"></a></dt>
<dd><p>Define or update the Fourier representation of a periodic function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – The utilisation mode (‘init’, ‘update’).
Use the ‘init’ mode to set the function representation
at random (default), or ‘update’ to change its parameters at
random. The default is ‘init’.</p></li>
<li><p><strong>M</strong> (<em>int</em><em>, </em><em>optional</em>) – M * 2 + 1 is the number of Fourier coefficients.
The default is 3.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute fparam.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.InitStepFunction">
<span class="sig-name descname"><span class="pre">InitStepFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ftype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'step-constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'init'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.InitStepFunction" title="Link to this definition"></a></dt>
<dd><p>Define or update a step function at random.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ftype</strong> (<em>str</em><em>, </em><em>optional</em>) – The type of step function.
(‘step’,’step-constant’,’step-ridge’,’step-smooth’).
The default is ‘step-constant’.</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – The utilisation mode (‘init’, ‘update’).
The default is ‘init’.</p></li>
<li><p><strong>M</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of steps. The default is 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attributes fparam, finter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.SampleFourierCoefficients">
<span class="sig-name descname"><span class="pre">SampleFourierCoefficients</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.SampleFourierCoefficients" title="Link to this definition"></a></dt>
<dd><p>Sample the Fourier coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Attribute fparam.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.SampleStepConstants">
<span class="sig-name descname"><span class="pre">SampleStepConstants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.SampleStepConstants" title="Link to this definition"></a></dt>
<dd><p>Sample constants within (0, 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>k</strong> (<em>int</em><em>, </em><em>optional</em>) – index where to put the minimal value. The default is -1.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute fparam.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The simulation of the step constants depends on
the attribute smode:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>smode[0]=’unif’:</dt><dd><p>step values are sampled from a uniform
distribution on (smode[1], smode[2]).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>smode[0]=’unifmin’:</dt><dd><p>the minimal step value is sampled from a
uniform distribution on (smode[1], smode[2]).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>smode[0]=’unifrange’:</dt><dd><p>the step value range is sampled from a
uniform distribution on (0, smode[2] - smode[1]).</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The mode of simulation can be changed using
<a class="reference internal" href="#setstepsamplemode">SetStepSampleMode</a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.SampleStepIntervals">
<span class="sig-name descname"><span class="pre">SampleStepIntervals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.SampleStepIntervals" title="Link to this definition"></a></dt>
<dd><p>Sample interval bounds of a step function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The index of the interval whose size is uniformly sampled.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The simulation of the step constants depends
on the attribute smode:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>smode[3]=’unif’:</dt><dd><p>the bounds are uniformly sampled over
the interval (-pi/2, pi/2).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>smode[3]=’nonunif’:</dt><dd><p>the bounds are sampled so that the
size of one of them is uniformly sampled.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>smode[4] is a minimal interval size.</p>
<p>The mode of simulation can be changed using
<a class="reference internal" href="#setstepsamplemode">SetStepSampleMode</a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.Save">
<span class="sig-name descname"><span class="pre">Save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.Save" title="Link to this definition"></a></dt>
<dd><p>Save a periodic function in a file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str.</em>) – address of the file.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function can be rebuilt using the function LoadPerfunction.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.SetStepSampleMode">
<span class="sig-name descname"><span class="pre">SetStepSampleMode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode_cst</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unif'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unif'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.SetStepSampleMode" title="Link to this definition"></a></dt>
<dd><p>Set the simulation mode for sampling parameters of a step function.</p>
<dl class="field-list simple" id="setstepsamplemode">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mode_cst</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>The mode of simulation of constants <span class="math notranslate nohighlight">\(a_m\)</span>:</p>
<ul>
<li><dl class="simple">
<dt>if mode_cst = ‘unif’:</dt><dd><p>step values are sampled from a uniform distribution on (a, b).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>if mode_cst = ‘unifmin’:</dt><dd><p>the minimal step value is sampled from a uniform distribution
on (a, b).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>if mode_cst = ‘unifrange’:</dt><dd><p>the step value range is sampled from a uniform distribution
on (a, b).</p>
</dd>
</dl>
</li>
</ul>
<p>The default is ‘unif’.</p>
</p></li>
<li><p><strong>a</strong> (<em>float</em><em>, </em><em>optional</em>) – lower bound. The default is 0.</p></li>
<li><p><strong>b</strong> (<em>float</em><em>, </em><em>optional</em>) – upper bound. The default is 1.</p></li>
<li><p><strong>mode_int</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>The mode of simulation of interval bounds
<span class="math notranslate nohighlight">\(\psi_m\)</span>:</p>
<ul>
<li><dl class="simple">
<dt>if mode_int=’unif’:</dt><dd><p>the bounds are uniformly sampled over the interval
(-pi/2, pi/2).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>if mode_int=’nonunif’:</dt><dd><p>the bounds are sampled so that the size
of one of them is uniformly sampled.</p>
</dd>
</dl>
</li>
</ul>
<p>The default is ‘unif’.</p>
</p></li>
<li><p><strong>d</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimal value of interval size. The default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute smode.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.SetUniformStepInterval">
<span class="sig-name descname"><span class="pre">SetUniformStepInterval</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.SetUniformStepInterval" title="Link to this definition"></a></dt>
<dd><p>Set uniform step intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Attribute finter, trans.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.PeriodicFunction.perfunction.ShowParameters">
<span class="sig-name descname"><span class="pre">ShowParameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.PeriodicFunction.perfunction.ShowParameters" title="Link to this definition"></a></dt>
<dd><p>Show the parameters of the function.</p>
</dd></dl>

</dd></dl>

</section>
<section id="coordinates-coordinates">
<h2>Coordinates (<em>coordinates</em>)<a class="headerlink" href="#coordinates-coordinates" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.coordinates">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">afbf.Classes.SpatialData.</span></span><span class="sig-name descname"><span class="pre">coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.coordinates" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class handles a set of coordinates in the plane.</p>
<p id="coordinates">Coordinates are pairs (x, y) of integers referring to a plane position
(x / N, y / N). Set of coordinates can either be on a uniform grid
or at arbitrary positions.</p>
<p>A uniform grid is defined as <span class="math notranslate nohighlight">\([\![1, N]\!] \times  [\![1, N]\!]\)</span>.
It can also be signed, in which case it is of the form
<span class="math notranslate nohighlight">\([\![1, N]\!] \times  [\![-N, N]\!]\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><p>Define and display a grid of size 10 x 10.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">afbf</span><span class="w"> </span><span class="kn">import</span> <span class="n">coordinates</span>
<span class="n">coord</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">coord</span><span class="o">.</span><span class="n">Display</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/grid.png" src="_images/grid.png" />
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xy</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a> of shape (ncoord, 2)) – set of Cartesian coordinates; xy[m, :] are the mth coordinates.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Factor to be applied to coordinates.</p></li>
<li><p><strong>Nx</strong> (<em>int</em>) – Grid dimension: number of x coordinates.</p></li>
<li><p><strong>Ny</strong> (<em>int</em>) – Grid dimension: number of y coordinates.</p></li>
<li><p><strong>grid</strong> (<em>bool</em>) – True if grid coordinates.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.coordinates.ApplyAffineTransform">
<span class="sig-name descname"><span class="pre">ApplyAffineTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.coordinates.ApplyAffineTransform" title="Link to this definition"></a></dt>
<dd><p>Apply an affine transform A to coordinates.</p>
<p>Given a matrix <span class="math notranslate nohighlight">\(A\)</span> of shape (2, 2) and coordinates
<span class="math notranslate nohighlight">\((x, y)\)</span>,
the transform is defined as</p>
<div class="math notranslate nohighlight">
\[(\tilde x, \tilde y) = (x, y) A.\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – An array of shape (2, 2) of type int defining the
affine transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attributes xy.</p>
</dd>
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><p>Apply an affine transform to a uniform grid.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">afbf</span><span class="w"> </span><span class="kn">import</span> <span class="n">coordinates</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">array</span>

<span class="n">coord</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">coord</span><span class="o">.</span><span class="n">Display</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">coord</span><span class="o">.</span><span class="n">ApplyAffineTransform</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">coord</span><span class="o">.</span><span class="n">Display</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/coordaff.png" src="_images/coordaff.png" />
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.coordinates.CheckValidity">
<span class="sig-name descname"><span class="pre">CheckValidity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.coordinates.CheckValidity" title="Link to this definition"></a></dt>
<dd><p>Check the validity of coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if attributes are properly defined, and false otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.coordinates.DefineNonUniformLocations">
<span class="sig-name descname"><span class="pre">DefineNonUniformLocations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.coordinates.DefineNonUniformLocations" title="Link to this definition"></a></dt>
<dd><p>Import a set of positions provided in an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xy</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – An array of size (ncoord, 2) containing
coordinates: xy[m, :] are the mth coordinates.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attributes xy, M, N, grid.</p>
</dd>
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><p>Define coordinates at some given positions.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">afbf</span><span class="w"> </span><span class="kn">import</span> <span class="n">coordinates</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">array</span>

<span class="n">xy</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">coord</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">()</span>
<span class="n">coord</span><span class="o">.</span><span class="n">DefineNoneUniformLocations</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.coordinates.DefineSparseSemiBall">
<span class="sig-name descname"><span class="pre">DefineSparseSemiBall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.coordinates.DefineSparseSemiBall" title="Link to this definition"></a></dt>
<dd><p>Define a sparse semi-ball.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>N</strong> (<em>int</em>) – number of x- and y- coordinates.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attributes xy, N, Nx, Ny, grid.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.coordinates.DefineUniformGrid">
<span class="sig-name descname"><span class="pre">DefineUniformGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.coordinates.DefineUniformGrid" title="Link to this definition"></a></dt>
<dd><p>Define a uniform grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>int</em>) – number of x- and y- coordinates.</p></li>
<li><p><strong>step</strong> (<em>int</em><em>, </em><em>optional</em>) – step between grid points. Default to 1.</p></li>
<li><p><strong>signed</strong> (<em>boolean</em><em>, </em><em>optional</em>) – True if the grid is to be signed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attributes xy, N, Nx, Ny, grid.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.coordinates.Display">
<span class="sig-name descname"><span class="pre">Display</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nfig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.coordinates.Display" title="Link to this definition"></a></dt>
<dd><p>Display the positions given by coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nfig</strong> (<em>int</em><em>, </em><em>optional</em>) – The index of the figure. Default to 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.coordinates.ProjectOnAxis">
<span class="sig-name descname"><span class="pre">ProjectOnAxis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.coordinates.ProjectOnAxis" title="Link to this definition"></a></dt>
<dd><p>Project coordinates on an axis oriented in (u, v).</p>
<p>Given the axis <span class="math notranslate nohighlight">\((u, v)\)</span> and coordinates <span class="math notranslate nohighlight">\((x, y)\)</span>,
the projection is given by</p>
<div class="math notranslate nohighlight">
\[z = u\: x + v \: y\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>int u</em><em>,</em>) – The projection axis.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Projection coordinates.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a> of shape (ncoord, 2)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="spatial-data-sdata">
<h2>Spatial data (<em>sdata</em>)<a class="headerlink" href="#spatial-data-sdata" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.sdata">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">afbf.Classes.SpatialData.</span></span><span class="sig-name descname"><span class="pre">sdata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'undefined'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.sdata" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class handles spatial data.</p>
<p id="sdata">Spatial data includes but are not restricted to images.
Images are particular spatial data defined on a uniform grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coord</strong> (<a class="reference internal" href="#afbf.Classes.SpatialData.coordinates" title="afbf.Classes.SpatialData.coordinates"><em>coordinates</em></a>) – Coordinates where data are defined.</p></li>
<li><p><strong>values</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – Spatial values observed at each position of coord;
values[m] is the value observed at position coord[m, :].</p></li>
</ul>
</dd>
</dl>
<p>:param <a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a> M: size of the image (number of rows, columns).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of data. Default to ‘undefined’.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.sdata.ComputeEmpiricalSemiVariogram">
<span class="sig-name descname"><span class="pre">ComputeEmpiricalSemiVariogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lags</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.sdata.ComputeEmpiricalSemiVariogram" title="Link to this definition"></a></dt>
<dd><p>Compute the empirical semi-variogram of an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>lags</strong> (<a class="reference internal" href="#coordinates">coordinates</a>) – Lags at which to compute quadratic variations.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The semi-variogram.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#afbf.Classes.SpatialData.sdata" title="afbf.Classes.SpatialData.sdata">sdata</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method only applies to an image.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.sdata.ComputeImageSign">
<span class="sig-name descname"><span class="pre">ComputeImageSign</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.sdata.ComputeImageSign" title="Link to this definition"></a></dt>
<dd><p>Compute the sign of an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The sign image.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#afbf.Classes.SpatialData.sdata" title="afbf.Classes.SpatialData.sdata">sdata</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.sdata.ComputeIncrements">
<span class="sig-name descname"><span class="pre">ComputeIncrements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.sdata.ComputeIncrements" title="Link to this definition"></a></dt>
<dd><p>Compute increments of an image.</p>
<p>Given some lags <span class="math notranslate nohighlight">\((h_x, h_y)\)</span> and
an order <span class="math notranslate nohighlight">\(J\)</span>, increments <span class="math notranslate nohighlight">\(Z\)</span> of order <span class="math notranslate nohighlight">\(J\)</span>
of the image form an image defined in a recursive way by</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left\{ \begin{array}{l}
X^{(0)} = X, \\
X^{(j+1)} [x, y] = X^{(j)}[x, y] - X^{(j)}[x - h_x, y - h_y],
\:\: \mathrm{for} \:\: j = 0, \cdots, J, \\
Z = X^{(J+1)}.
\end{array}\right.\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hy</strong> (<em>int hx</em><em>,</em>) – Horizontal and vertical lags.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – Order of the increment. The default value is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The increment image.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#afbf.Classes.SpatialData.sdata" title="afbf.Classes.SpatialData.sdata">sdata</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.sdata.ComputeLaplacian">
<span class="sig-name descname"><span class="pre">ComputeLaplacian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.sdata.ComputeLaplacian" title="Link to this definition"></a></dt>
<dd><p>Compute the discrete laplacian of an image.</p>
<p>Given some scale <span class="math notranslate nohighlight">\(s\)</span>, the Laplacian <span class="math notranslate nohighlight">\(Z\)</span> of the image
is an image defined as</p>
<div class="math notranslate nohighlight">
\[Z[x, y] = 4 X[x, y]-X[x-s, y]-X[x+s, y]- X[x, y-s] - X[x, y+s].\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>scale</strong> (<em>int</em><em> , </em><em>optional</em>) – Scale at which the Laplacian is computed. Default to 1.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The image Laplacian.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#afbf.Classes.SpatialData.sdata" title="afbf.Classes.SpatialData.sdata">sdata</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.sdata.ComputeQuadraticVariations">
<span class="sig-name descname"><span class="pre">ComputeQuadraticVariations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lags</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.sdata.ComputeQuadraticVariations" title="Link to this definition"></a></dt>
<dd><p>Compute the quadratic variations of an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>lags</strong> (<a class="reference internal" href="#coordinates">coordinates</a>) – Lags at which to compute quadratic variations.</p>
</dd>
<dt class="field-even">Aram order<span class="colon">:</span></dt>
<dd class="field-even"><p>The order of the quadratic variations. The default is 0.</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Quadratic variations.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#afbf.Classes.SpatialData.sdata" title="afbf.Classes.SpatialData.sdata">sdata</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method only applies to an image.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.sdata.CreateImage">
<span class="sig-name descname"><span class="pre">CreateImage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.sdata.CreateImage" title="Link to this definition"></a></dt>
<dd><p>Create an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – An array of size 2 giving the number of rows and columns of
the matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute coord.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.sdata.Display">
<span class="sig-name descname"><span class="pre">Display</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nfig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.sdata.Display" title="Link to this definition"></a></dt>
<dd><p>Display an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nfig</strong> (<em>int</em><em>, </em><em>optional</em>) – Figure index. Default to 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.sdata.ImportImage">
<span class="sig-name descname"><span class="pre">ImportImage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.sdata.ImportImage" title="Link to this definition"></a></dt>
<dd><p>Import an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str.</em>) – Physical address of the image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.SpatialData.sdata.Save">
<span class="sig-name descname"><span class="pre">Save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.SpatialData.sdata.Save" title="Link to this definition"></a></dt>
<dd><p>Save an image in a file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – File name (without extension).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="process-process">
<h2>Process (<em>process</em>)<a class="headerlink" href="#process-process" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">afbf.Classes.RandomProcess.</span></span><span class="sig-name descname"><span class="pre">process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fbm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class handles random processes, with a focus on fractional Brownian
motions (FBM).</p>
<p id="process">A FBM is a Gaussian <a class="reference internal" href="glossary.html#term-random-field"><span class="xref std std-term">random process</span></a>
with <a class="reference internal" href="glossary.html#term-stationarity"><span class="xref std std-term">stationary</span></a> <a class="reference internal" href="glossary.html#term-increments"><span class="xref std std-term">increments</span></a>. Its properties
(<a class="reference internal" href="glossary.html#term-regularity"><span class="xref std std-term">regularity</span></a>, order of self-similarity, …)
are determined by a single parameter <span class="math notranslate nohighlight">\(H \in (0, 1)\)</span>,
called the Hurst index.</p>
<dl class="field-list simple">
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><p>Simulation of a FBF with Hurst index <span class="math notranslate nohighlight">\(H=0.2\)</span> at
times <span class="math notranslate nohighlight">\(\{1, \cdots, T\}\)</span>.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">afbf</span><span class="w"> </span><span class="kn">import</span> <span class="n">process</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s1">&#39;fbm&#39;</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">Simulate</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">Display</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/mbf.png" src="_images/mbf.png" />
<p>:param <a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a> autocov: The autocovariance of the process.</p>
<p>:param <a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a> spect: The Fourier spectrum of the autocovariance.</p>
<p>:param <a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a> vario: The semi-variogram of the process.</p>
<p>:param <a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a> y: The values of a simulation of the process.</p>
<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process.ComputeAutocovariance">
<span class="sig-name descname"><span class="pre">ComputeAutocovariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process.ComputeAutocovariance" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Compute the autocovariance of the process increments</dt><dd><p>at uniformly-spaced lags <span class="math notranslate nohighlight">\(\{0, 1,  \cdots, T\}\)</span>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>T</strong> (<em>int</em>) – The maximal lag. Default is 10.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute autocov.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process.ComputeAutocovarianceSpectrum">
<span class="sig-name descname"><span class="pre">ComputeAutocovarianceSpectrum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process.ComputeAutocovarianceSpectrum" title="Link to this definition"></a></dt>
<dd><p>Compute the Fourier spectrum of the periodized autocovariance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Attribute spect.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process.ComputeFBMAutocovariance">
<span class="sig-name descname"><span class="pre">ComputeFBMAutocovariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process.ComputeFBMAutocovariance" title="Link to this definition"></a></dt>
<dd><p>Compute the autocovariance of the increments of a fractional
Brownian motion of Hurst index <span class="math notranslate nohighlight">\(H\)</span> at
uniformly-spaced lags <span class="math notranslate nohighlight">\(\{0, 1, \cdots, T-1 \}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>T</strong> (<em>int</em>) – The maximal lag.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute autocov.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process.ComputeFBMSemiVariogram">
<span class="sig-name descname"><span class="pre">ComputeFBMSemiVariogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lags</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logvario</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process.ComputeFBMSemiVariogram" title="Link to this definition"></a></dt>
<dd><p>Compute the semi-variogram of the fbm at lags given in lags.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lags</strong> (<a class="reference internal" href="#afbf.utilities.ndarray" title="afbf.utilities.ndarray"><em>ndarray</em></a>) – Lags where to compute the variogram.</p></li>
<li><p><strong>logvario</strong> (<em>int</em><em>, </em><em>optional</em>) – if logvario&gt;0, a log semi-variogram is computed.
The default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute vario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process.ComputeSemiVariogram">
<span class="sig-name descname"><span class="pre">ComputeSemiVariogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lags</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logvario</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process.ComputeSemiVariogram" title="Link to this definition"></a></dt>
<dd><p>Compute the semi-variogram of the process at lags given in lags.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lags</strong> (<a class="reference internal" href="#afbf.utilities.ndarray" title="afbf.utilities.ndarray"><em>ndarray</em></a>) – Lags where to compute the variogram.</p></li>
<li><p><strong>logvario</strong> (<em>int</em><em>, </em><em>optional</em>) – if logvario&gt;0, a log semi-variogram is computed.
The default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute vario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process.Display">
<span class="sig-name descname"><span class="pre">Display</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nfig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process.Display" title="Link to this definition"></a></dt>
<dd><p>Display the realization of the process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nfig</strong> (<em>int</em><em>, </em><em>optional</em>) – Figure index. The default is 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process.ExtendFBM">
<span class="sig-name descname"><span class="pre">ExtendFBM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process.ExtendFBM" title="Link to this definition"></a></dt>
<dd><p>Extend the definition of a FBM to a non self-similar process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of parameters used for defining the extension
function. The default is 5.</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><p>Simulation of an extended FBF with Hurst index <span class="math notranslate nohighlight">\(H=0.2\)</span>
at times <span class="math notranslate nohighlight">\(\{1, \cdots, T\}\)</span>.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">afbf</span><span class="w"> </span><span class="kn">import</span> <span class="n">process</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s1">&#39;fbm&#39;</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">ExtendFBM</span><span class="p">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">Simulate</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">Display</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embf.png" src="_images/embf.png" />
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process.IntegrateProcess">
<span class="sig-name descname"><span class="pre">IntegrateProcess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process.IntegrateProcess" title="Link to this definition"></a></dt>
<dd><p>Integrate the process at a given order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>order</strong> (<em>int</em>) – The order of integration.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute y.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process.Simulate">
<span class="sig-name descname"><span class="pre">Simulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process.Simulate" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Simulate the process at uniformly-spaced positions</dt><dd><p><span class="math notranslate nohighlight">\(\{0, 1, \cdots, T\}\)</span>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>T</strong> (<em>int</em>) – The maximal lag.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute y.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Classes.RandomProcess.process.Simulate_CirculantCovarianceMethod">
<span class="sig-name descname"><span class="pre">Simulate_CirculantCovarianceMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Classes.RandomProcess.process.Simulate_CirculantCovarianceMethod" title="Link to this definition"></a></dt>
<dd><p>Simulate process <a class="reference internal" href="glossary.html#term-increments"><span class="xref std std-term">increments</span></a> at positions
<span class="math notranslate nohighlight">\(\{0, 1, \cdots, T\}\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method was developed by Wood and Chan.
It is described in <span id="id1">[<a class="reference internal" href="refs.html#id15" title="A. Wood and G. Chan. Simulation of stationary Gaussian processes in [0, 1]d. J. Comput. Graph. Statist., 3(4):409–432, 1994.">14</a>]</span>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>T</strong> (<em>int</em>) – The maximal lag.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attribute y.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="variable-projection-minimize">
<h2>Variable projection (<em>minimize</em>)<a class="headerlink" href="#variable-projection-minimize" title="Link to this heading"></a></h2>
</section>
<section id="turning-bands-tbparameters">
<h2>Turning bands (<em>tbparameters</em>)<a class="headerlink" href="#turning-bands-tbparameters" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="afbf.Simulation.TurningBands.tbparameters">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">afbf.Simulation.TurningBands.</span></span><span class="sig-name descname"><span class="pre">tbparameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">K</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Simulation.TurningBands.tbparameters" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class handles parameters of the turning band field.</p>
<dl class="field-list simple" id="tbparameters">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>K</strong> (<em>int</em>) – the number of bands.</p></li>
<li><p><strong>Kangle</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – <p>Angles of the turning bands.
The tangent of each angle <span class="math notranslate nohighlight">\(\varphi\)</span> have a tangent which
satisfies</p>
<div class="math notranslate nohighlight">
\[\tan(\varphi) = \frac{p}{q},\]</div>
<p>for some <span class="math notranslate nohighlight">\(p \in \mathbb{Z}\)</span> and <span class="math notranslate nohighlight">\(q \in \mathbb{N}^*\)</span>.</p>
</p></li>
<li><p><strong>Pangle</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – Denominators <span class="math notranslate nohighlight">\(q\)</span> of angle tangents.</p></li>
<li><p><strong>Qangle</strong> (<a class="reference internal" href="#ndarray"><span class="std std-ref">ndarray</span></a>) – Numerators <span class="math notranslate nohighlight">\(p\)</span> of angle tangents.</p></li>
<li><p><strong>cost</strong> (<em>scalar</em>) – Angle cost (dynamic programming).</p></li>
<li><p><strong>acc</strong> (<em>scalar</em>) – Precision (dynamic programming).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="afbf.Simulation.TurningBands.tbparameters.DisplayInformation">
<span class="sig-name descname"><span class="pre">DisplayInformation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Simulation.TurningBands.tbparameters.DisplayInformation" title="Link to this definition"></a></dt>
<dd><p>Display information about simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Simulation.TurningBands.tbparameters.OptimalAngles">
<span class="sig-name descname"><span class="pre">OptimalAngles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Simulation.TurningBands.tbparameters.OptimalAngles" title="Link to this definition"></a></dt>
<dd><p>Compute a set of optimal angles by dynamic programming.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>N</strong> (<em>scalar</em>) – The expected precision.
if <span class="math notranslate nohighlight">\(N &lt; 1\)</span>, the precision is set to N
else the precision (in radians) is set to <span class="math notranslate nohighlight">\(\frac{pi}{N}\)</span>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attributes Kangle, Pangle, Qangle.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The dynamic programming algorithm finds an optimal subset
<span class="math notranslate nohighlight">\(S'\)</span> of angles among a set <span class="math notranslate nohighlight">\(\Phi\)</span> of possible angles
whose tangents are rational. :math:<a href="#id2"><span class="problematic" id="id3">`</span></a>Phi`is a subset of</p>
<div class="math notranslate nohighlight">
\[\{\varphi \in [-\pi/2,\pi/2], \tan(\varphi)=p/q, p
\in \mathbb{Z}, q \in \mathbb{N}^\ast, p \wedge q=1\}.\]</div>
<p>A cost <span class="math notranslate nohighlight">\(C(\varphi)=\vert q \vert+p\)</span> is associated to each
angle <span class="math notranslate nohighlight">\(\varphi\)</span>.</p>
<p>The optimal subset <span class="math notranslate nohighlight">\(\Phi'\)</span> minimizes
<span class="math notranslate nohighlight">\(\sum_{\varphi \in \Phi'} C(\varphi)\)</span> under
the constraint that the difference between two
successive angles are below a given precision.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Simulation.TurningBands.tbparameters.Precision">
<span class="sig-name descname"><span class="pre">Precision</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Simulation.TurningBands.tbparameters.Precision" title="Link to this definition"></a></dt>
<dd><p>Compute the precision of the turning bands.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Simulation.TurningBands.tbparameters.QuasiUniformAngles">
<span class="sig-name descname"><span class="pre">QuasiUniformAngles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">K</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Simulation.TurningBands.tbparameters.QuasiUniformAngles" title="Link to this definition"></a></dt>
<dd><p>Build a set of K angles which are approximately uniform
on the interval <span class="math notranslate nohighlight">\([-\frac{\pi}{2},\frac{\pi}{2}]\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>K</strong> (<em>int</em><em>, </em><em>optional</em>) – A number of angles. The default is 100000.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Attributes Kangle, Pangle, Qangle.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="afbf.Simulation.TurningBands.tbparameters.SimulationCost">
<span class="sig-name descname"><span class="pre">SimulationCost</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#afbf.Simulation.TurningBands.tbparameters.SimulationCost" title="Link to this definition"></a></dt>
<dd><p>Compute the computational cost associated to the turning bands.</p>
</dd></dl>

</dd></dl>

</section>
<section id="ndarray">
<span id="id4"></span><h2>ndarray<a class="headerlink" href="#ndarray" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="afbf.utilities.ndarray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">afbf.utilities.</span></span><span class="sig-name descname"><span class="pre">ndarray</span></span><a class="headerlink" href="#afbf.utilities.ndarray" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>ndarray(shape, dtype=float, buffer=None, offset=0,</dt><dd><p>strides=None, order=None)</p>
</dd>
</dl>
<p>An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)</p>
<p>Arrays should be constructed using <cite>array</cite>, <cite>zeros</cite> or <cite>empty</cite> (refer
to the See Also section below).  The parameters given here refer to
a low-level method (<cite>ndarray(…)</cite>) for instantiating an array.</p>
<p>For more information, refer to the <cite>numpy</cite> module and examine the
methods and attributes of an array.</p>
<section id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="Link to this heading"></a></h3>
<p>(for the __new__ method; see Notes below)</p>
<dl class="simple">
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape of created array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Any object that can be interpreted as a numpy data type.</p>
</dd>
<dt>buffer<span class="classifier">object exposing buffer interface, optional</span></dt><dd><p>Used to fill the array with data.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Offset of array data in buffer.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints, optional</span></dt><dd><p>Strides of data in memory.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Row-major (C-style) or column-major (Fortran-style) order.</p>
</dd>
</dl>
</section>
<section id="attributes">
<h3>Attributes<a class="headerlink" href="#attributes" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>T<span class="classifier">ndarray</span></dt><dd><p>Transpose of the array.</p>
</dd>
<dt>data<span class="classifier">buffer</span></dt><dd><p>The array’s elements, in memory.</p>
</dd>
<dt>dtype<span class="classifier">dtype object</span></dt><dd><p>Describes the format of the elements in the array.</p>
</dd>
<dt>flags<span class="classifier">dict</span></dt><dd><p>Dictionary containing information related to memory use, e.g.,
‘C_CONTIGUOUS’, ‘OWNDATA’, ‘WRITEABLE’, etc.</p>
</dd>
<dt>flat<span class="classifier">numpy.flatiter object</span></dt><dd><p>Flattened version of the array as an iterator.  The iterator
allows assignments, e.g., <code class="docutils literal notranslate"><span class="pre">x.flat</span> <span class="pre">=</span> <span class="pre">3</span></code> (See <cite>ndarray.flat</cite> for
assignment examples; TODO).</p>
</dd>
<dt>imag<span class="classifier">ndarray</span></dt><dd><p>Imaginary part of the array.</p>
</dd>
<dt>real<span class="classifier">ndarray</span></dt><dd><p>Real part of the array.</p>
</dd>
<dt>size<span class="classifier">int</span></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt>itemsize<span class="classifier">int</span></dt><dd><p>The memory use of each array element in bytes.</p>
</dd>
<dt>nbytes<span class="classifier">int</span></dt><dd><p>The total number of bytes required to store the array data,
i.e., <code class="docutils literal notranslate"><span class="pre">itemsize</span> <span class="pre">*</span> <span class="pre">size</span></code>.</p>
</dd>
<dt>ndim<span class="classifier">int</span></dt><dd><p>The array’s number of dimensions.</p>
</dd>
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape of the array.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints</span></dt><dd><p>The step-size required to move from one element to the next in
memory. For example, a contiguous <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code> array of type
<code class="docutils literal notranslate"><span class="pre">int16</span></code> in C-order has strides <code class="docutils literal notranslate"><span class="pre">(8,</span> <span class="pre">2)</span></code>.  This implies that
to move from element to element in memory requires jumps of 2 bytes.
To move from row-to-row, one needs to jump 8 bytes at a time
(<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4</span></code>).</p>
</dd>
<dt>ctypes<span class="classifier">ctypes object</span></dt><dd><p>Class containing properties of the array needed for interaction
with ctypes.</p>
</dd>
<dt>base<span class="classifier">ndarray</span></dt><dd><p>If the array is a view into another array, that array is its <cite>base</cite>
(unless that array is also a view).  The <cite>base</cite> array is where the
array data is actually stored.</p>
</dd>
</dl>
</section>
<section id="see-also">
<h3>See Also<a class="headerlink" href="#see-also" title="Link to this heading"></a></h3>
<p>array : Construct an array.
zeros : Create an array, each element of which is zero.
empty : Create an array, but leave its allocated memory unchanged (i.e.,</p>
<blockquote>
<div><p>it contains “garbage”).</p>
</div></blockquote>
<p>dtype : Create a data-type.
numpy.typing.NDArray : An ndarray alias <span class="xref std std-term">generic</span></p>
<blockquote>
<div><p>w.r.t. its <cite>dtype.type &lt;numpy.dtype.type&gt;</cite>.</p>
</div></blockquote>
</section>
<section id="notes">
<h3>Notes<a class="headerlink" href="#notes" title="Link to this heading"></a></h3>
<p>There are two modes of creating an array using <code class="docutils literal notranslate"><span class="pre">__new__</span></code>:</p>
<ol class="arabic simple">
<li><p>If <cite>buffer</cite> is None, then only <cite>shape</cite>, <cite>dtype</cite>, and <cite>order</cite>
are used.</p></li>
<li><p>If <cite>buffer</cite> is an object exposing the buffer interface, then
all keywords are interpreted.</p></li>
</ol>
<p>No <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method is needed because the array is fully initialized
after the <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method.</p>
</section>
<section id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Link to this heading"></a></h3>
<p>These examples illustrate the low-level <cite>ndarray</cite> constructor.  Refer
to the <cite>See Also</cite> section above for easier ways of constructing an
ndarray.</p>
<p>First mode, <cite>buffer</cite> is None:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[0.0e+000, 0.0e+000], # random</span>
<span class="go">       [     nan, 2.5e-323]])</span>
</pre></div>
</div>
<p>Second mode:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span>
<span class="gp">... </span>           <span class="n">offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">()</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># offset = 1*itemsize, i.e. skip first element</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="field.html" class="btn btn-neutral float-left" title="API: main classes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="glossary.html" class="btn btn-neutral float-right" title="Glossary" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Frédéric Richard, 2021.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>